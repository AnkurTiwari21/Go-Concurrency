# Semaphores

- Semaphores is a sync mechanism which can limit the number of go-routines in crictical section.
- Unlike mutex which allows 1 go-routine to enter in critical section. Semaphores can allow upto N go-routines to be in critical section at the same time.
- A semaphore with only one permit is sometimes called a binary semaphore.

- *NOTE:* Although a mutex is a special case of a semaphore with one permit, there is a slight diﬀerence in how they are expected to be used. When using mutexes, the execution that is holding a mutex should also be the one to release it. When using semaphores, this is not always the case.
- A mutex enforces ownership, while a semaphore enforces availability. Even though a mutex can be implemented as a semaphore with one permit, their correct usage semantics are fundamentally different.

- Utilities:
1. New semaphore function—Creates a new semaphore with X permits.
2. Acquire permit function—A goroutine will take one permit from the semaphore. If none are available, the goroutine will suspend and wait until one becomes available.
3. Release permit function—Releases one permit so a goroutine can use it again with the acquire function.

- Go does not come with a semaphore type in its bundled libraries, but there is an extension sync package at
https://pkg.go.dev/golang.org/x/sync containing an implementation of a semaphore.

```
// remoteDeleteEmployeeRPC will delete an employee over the network.
func remoteDeleteEmployeeRPC() {
    ...
}
// sem is a weighted semaphore allowing up to 10 concurrent operations.
var sem = semaphore.NewWeighted(int64(10)) 
func main() {
   // a context is required for the weighted semaphore pkg.
   ctx := context.Background()
   for _, employee := range employeeList {
       if err := sem.Acquire(ctx, 1); err != nil { 
           // handle error and maybe break
       }
       go func(){ 
           remoteDeleteEmployeeRPC(employee.ID)
           sem.Release(1)
       }()
   }
}

```

