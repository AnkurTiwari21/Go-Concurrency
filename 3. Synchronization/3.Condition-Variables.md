# Sync.Cond package

- Synchronization through mutexes allows only 1 go-routine to be able to enter in the critical section. But what if we want more go-routines in our critical section. Not only more say we want to limit the number of go-routines on the basis of a condition.
- Consider example of go-routines making db calls. You dont want to bombard your db with 1000s of go-routines making db calls . So you need an option to track and limit number of go-routines that are there in critical section making db calls.

- For above reasons , we can use a synchronization primitive called Condition Variables which can be found in `Sync` package.

```
type Cond
func NewCond(l Locker) *Cond
func (c *Cond) Broadcast()
func (c *Cond) Signal()
func (c *Cond) Wait()


type Locker interface {
    Lock()
    Unlock()
}

```

- If you look carefully one of the type that implements the Locker interface is Sync.Mutex hence we can do
```
mutex := sync.Mutex{} 
cond := sync.NewCond(&mutex)
```

- A cond have methods like `Wait()` , `Signal()` and `Broadcast()`. 
- **Notes** : 
1. `Wait()` function releases the mutex and suspends the execution in an atomic manner . This means that another execution cannot come in between these two operations, acquire the lock, and call the Signal() function before the execution calling Wait() has been suspended.
2. Whenever a waiting goroutine receives a `signal` or `broadcast`, it will try to reacquire the mutex. If another execution is holding on to the mutex, the goroutine will remain suspended until the mutex becomes available.
3. If there is no goroutine in a waiting state, the Signal() or Broadcast() call will be missed.

Below example explains 3.
```
package main
import (
    "fmt"
    "sync"
)
func doWork(cond *sync.Cond) {
    fmt.Println("Work started")
    fmt.Println("Work finished")
    cond.Signal() 
}

func main() {
    cond := sync.NewCond(&sync.Mutex{})
    cond.L.Lock()
    for i := 0; i < 50000; i++ { 
        go doWork(cond) 
        fmt.Println("Waiting for child goroutine ")
        cond.Wait() 
        fmt.Println("Child goroutine finished")
    }
    cond.L.Unlock()
}
```
- The above exmaple panic because `doWork()` fired a `signal()` but main go-routine didn't reached `wait()` i.e the main go-routine wasn't waiting for any signal. Whenever go runtime detects any missed signal because this can cause sync issues between go-routine and may be deadlock.
- To solve above reason we can use the `mutex` that we passed while creating cond variable. We can improve doWork() as below:
```
func doWork(cond *sync.Cond) {
    fmt.Println("Work started")
    fmt.Println("Work finished")
    cond.L.Lock() 
    cond.Signal()
    cond.L.Unlock() 
}
```

- Remember from Note(1), wait() unlocks the mutex and suspends at the same time, hence the signal() in doWork() will never be triggered until Wait() will be hit in main() go-routine

**Notes:**
- When a group of goroutines is suspended on Wait() and we call Signal(), we only wake up one of the goroutines. We have no control over which goroutine the system will resume, and we should assume that it can be any goroutine blocked on the condition variableâ€™s Wait(). Using Broadcast() , we ensure that all suspended goroutines on the condition variable are resumed.
-  Always use Signal(), Broadcast(), and Wait() when holding the mutex lock to avoid synchronization problems.
