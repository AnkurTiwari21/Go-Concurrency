# Escape-Analysis

**Defn:** In general, when a function in Go creates a variable, the Go compiler decides whether the variable should be allocated on the stack or the heap. This process of "deciding" is called escape analysis, and as you can guess, it's happening at compile time (and not at runtime).

| Aspect  | Stack Allocation | Heap Allocation |
| ------------- |:-------------:|:-------------:|
| Allocation Criteria      | If the variable doesn't escape the scope of the function where it is defined (i.e., it is not returned or referenced outside), it can be safely allocated on the stack.     | If the variable escapes (for example, by being returned from the function or captured by a goroutine), it must be allocated on the heap to ensure that it remains accessible after the function returns.     |
| Performance    | Faster due to simple pointer manipulation.     | Slower due to dynamic memory allocation.     |
| Garbage Collection Pressure      | None. Memory is automatically reclaimed when function returns.     | May cause overhead due to garbage collection.     |
| Memory Efficiency | Generally more efficient due to cache locality and automatic deallocation. | May be less efficient due to fragmentation and overhead. |


*Checking:*
```
go build -gcflags "-m" main.go
```

*Example:*
```
package main

import (
	"fmt"
)

func main() {
	slice := make([]int, 10)

	fmt.Print("size ", len(slice))
}
```

*Output:*
```
>> go build -gcflags "-m" main.go
# command-line-arguments
./main.go:10:11: inlining call to fmt.Print
./main.go:8:15: make([]int, 10) does not escape
./main.go:10:11: ... argument does not escape
./main.go:10:12: "size " escapes to heap
./main.go:10:24: len(slice) escapes to heap
```

**Step-by-step decoding:**
1. ```make([]int, 10) does not escape```
- slice is allocated on the stack
- The compiler proved:
    - slice is only used inside main
    - It is not returned, stored globally, or passed somewhere that outlives main

2. ```inlining call to fmt.Print``` 
- The compiler inlined fmt.Print
- This means it replaced the function call with the function body

3. ```"size " escapes to heap```
- Although "size " is a constant, when passed to fmt.Print:
    - fmt.Print accepts arguments as ...interface{}
    - That means:
        - "size " must be boxed into an interface
    - Interface values may be stored beyond the current stack frame
    - The compiler cannot guarantee lifetime safety, so it moves it to the heap

**Even string literals can escape when used as interface{}.**

4. ```len(slice) escapes to heap```
- len(slice) returns an int
- That int is passed to fmt.Print
- fmt.Print takes ...interface{}
- So the int must be:
    - Boxed into an interface{}
- Which may outlive the function

Therefore â†’ heap allocation

ðŸ“Œ Itâ€™s not len(slice) itself escaping. Itâ€™s the interface conversion of the result


To avoid (4.) we can do 
* ```fmt.Print("size ", len(slice))``` . Now only len(slice) escapes to heap, not the string literal
* Write directly to stdout
    ```
    os.Stdout.WriteString("size ")
    os.Stdout.WriteString(strconv.Itoa(len(slice)))
    ```
    - Nothing escape to heap

<hr>

**Cheat Sheet:**

- Function variables are allocated on the stack only if the Go compiler can prove that they won't be needed after the function returns. If a variable might be needed after the function returns, it's allocated on the heap to ensure it remains accessible, avoiding dangling pointers.
- when the compiler doesn't know the size of the variable at compile time, it allocates it on the heap. This is common for slices, maps, and channels,
- Very large local variables, like big slices, are typically allocated on the heap instead of the stack to prevent stack overflow and manage memory more efficiently.
- Variables that are stored in interfaces, Maps, Chanels, Slices and Strings are usually allocated on the heap.
- Anonymous functions and variables that are captured by a closure, are usually allocated on the heap
- Passing pointers or references to other functions typically allows variables to stay on the stack, unless these variables need to be used after the calling function has returned.
- Returning pointers or references from a function generally results in the variable being allocated on the heap. This ensures the variable remains accessible even after the function exits.

*"Only if, usually, unless..."* - I used these words because nothing is 100% acurate, and the best thing you can when you're unsure is to check the escape analysis output.